<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DecompilerSettings_AddUsingDeclarations" xml:space="preserve">
    <value>Add using declarations</value>
  </data>
  <data name="DecompilerSettings_AggressiveInlining" xml:space="preserve">
    <value>Always inline local variables if possible</value>
  </data>
  <data name="DecompilerSettings_AllowFieldInitializers" xml:space="preserve">
    <value>Allow field initializers</value>
  </data>
  <data name="DecompilerSettings_AlwaysCastTargetsOfExplicitInterfaceImplementationCalls" xml:space="preserve">
    <value>Always cast targets of explicit interface implementation calls</value>
  </data>
  <data name="DecompilerSettings_AlwaysGenerateExceptionVariableForCatchBlocksUnlessTypeIsObject" xml:space="preserve">
    <value>Always generate exception variables in catch blocks unless type is Object</value>
  </data>
  <data name="DecompilerSettings_AlwaysQualifyMemberReferences" xml:space="preserve">
    <value>Always qualify member references</value>
  </data>
  <data name="DecompilerSettings_AlwaysShowEnumMemberValues" xml:space="preserve">
    <value>Always show enum member values</value>
  </data>
  <data name="DecompilerSettings_AlwaysUseBraces" xml:space="preserve">
    <value>Always use braces</value>
  </data>
  <data name="DecompilerSettings_AlwaysUseGlobal" xml:space="preserve">
    <value>Always fully qualify namespaces using the "global::" prefix</value>
  </data>
  <data name="DecompilerSettings_CodeStyle" xml:space="preserve">
    <value>Code style</value>
  </data>
  <data name="DecompilerSettings_DecompilerBehavior" xml:space="preserve">
    <value>Decompiler behavior</value>
  </data>
  <data name="DecompilerSettings_MemberOrderingAndSorting" xml:space="preserve">
    <value>Member ordering and sorting</value>
  </data>
  <data name="DecompilerSettings_DecompilationOrder" xml:space="preserve">
    <value>Decompilation order</value>
  </data>
  <data name="DecompilerSettings_DecompileAnonMethods" xml:space="preserve">
    <value>Decompile anonymous methods/lambdas</value>
  </data>
  <data name="DecompilerSettings_DecompileAsyncMethods" xml:space="preserve">
    <value>Decompile async methods (async/await)</value>
  </data>
  <data name="DecompilerSettings_DecompileAutoEvents" xml:space="preserve">
    <value>Decompile automatic events</value>
  </data>
  <data name="DecompilerSettings_DecompileAutoProps" xml:space="preserve">
    <value>Decompile automatic properties</value>
  </data>
  <data name="DecompilerSettings_DecompileEnumerators" xml:space="preserve">
    <value>Decompile enumerators (yield return)</value>
  </data>
  <data name="DecompilerSettings_DecompileExprTrees" xml:space="preserve">
    <value>Decompile expression trees</value>
  </data>
  <data name="DecompilerSettings_DecompileForeachStatements" xml:space="preserve">
    <value>Decompile foreach statements</value>
  </data>
  <data name="DecompilerSettings_DecompileLockStatements" xml:space="preserve">
    <value>Decompile lock statements</value>
  </data>
  <data name="DecompilerSettings_DecompileQueryExpr" xml:space="preserve">
    <value>Decompile query expressions</value>
  </data>
  <data name="DecompilerSettings_DecompileSwitchOnString" xml:space="preserve">
    <value>Decompile switch on string</value>
  </data>
  <data name="DecompilerSettings_DecompileUsingStatements" xml:space="preserve">
    <value>Decompile using statements</value>
  </data>
  <data name="DecompilerSettings_DecompileDecimalConstantAsSimpleLiteralValues" xml:space="preserve">
    <value>Decompile [DecimalConstant(...)] as simple literal values</value>
  </data>
  <data name="DecompilerSettings_DecompileC10PublicUnsafeFixedIntArr10Members" xml:space="preserve">
    <value>Decompile C# 1.0 'public unsafe fixed int arr[10];' members</value>
  </data>
  <data name="DecompilerSettings_StringConcat" xml:space="preserve">
    <value>Decompile 'string.Concat(a, b)' calls into 'a + b'</value>
  </data>
  <data name="DecompilerSettings_DecompileAutomaticEvents" xml:space="preserve">
    <value>Decompile automatic events</value>
  </data>
  <data name="DecompilerSettings_SparseIntegerSwitch" xml:space="preserve">
    <value>Detect switch on integer even if IL code does not use a jump table</value>
  </data>
  <data name="DecompilerSettings_SeparateLocalVariableDeclarations" xml:space="preserve">
    <value>Separate local variable declarations and initializers (int x = 5; -&gt; int x; x = 5;), if possible</value>
  </data>
  <data name="DecompilerSettings_ArrayInitializerExpressions" xml:space="preserve">
    <value>Array initializer expressions</value>
  </data>
  <data name="DecompilerSettings_ForStatement" xml:space="preserve">
    <value>Transform to for, if possible</value>
  </data>
  <data name="DecompilerSettings_DoWhileStatement" xml:space="preserve">
    <value>Transform to do-while, if possible</value>
  </data>
  <data name="DecompilerSettings_UseLiftedOperatorsForNullables" xml:space="preserve">
    <value>Use lifted operators for nullables</value>
  </data>
  <data name="DecompilerSettings_UseImplicitMethodGroupConversions" xml:space="preserve">
    <value>Use implicit method group conversions</value>
  </data>
  <data name="DecompilerSettings_DecompileAnonymousTypes" xml:space="preserve">
    <value>Decompile anonymous types</value>
  </data>
  <data name="DecompilerSettings_UseLambdaSyntaxIfPossible" xml:space="preserve">
    <value>Use lambda syntax, if possible</value>
  </data>
  <data name="DecompilerSettings_DecompileAutomaticProperties" xml:space="preserve">
    <value>Decompile automatic properties</value>
  </data>
  <data name="DecompilerSettings_UseExtensionMethodSyntax" xml:space="preserve">
    <value>Use extension method syntax</value>
  </data>
  <data name="DecompilerSettings_ObjectCollectionInitializerExpressions" xml:space="preserve">
    <value>Object/collection initializer expressions</value>
  </data>
  <data name="DecompilerSettings_DecompileUseOfTheDynamicType" xml:space="preserve">
    <value>Decompile use of the 'dynamic' type</value>
  </data>
  <data name="DecompilerSettings_UseNamedArguments" xml:space="preserve">
    <value>Use named arguments</value>
  </data>
  <data name="DecompilerSettings_RemoveOptionalArgumentsIfPossible" xml:space="preserve">
    <value>Remove optional arguments, if possible</value>
  </data>
  <data name="DecompilerSettings_DecompileAwaitInCatchFinallyBlocks" xml:space="preserve">
    <value>Decompile await in catch/finally blocks</value>
  </data>
  <data name="DecompilerSettings_NullPropagation" xml:space="preserve">
    <value>Decompile ?. and ?[] operators</value>
  </data>
  <data name="DecompilerSettings_GetterOnlyAutomaticProperties" xml:space="preserve">
    <value>Decompile getter-only automatic properties</value>
  </data>
  <data name="DecompilerSettings_DictionaryInitializerExpressions" xml:space="preserve">
    <value>Dictionary initializer expressions</value>
  </data>
  <data name="DecompilerSettings_AllowExtensionAddMethodsInCollectionInitializerExpressions" xml:space="preserve">
    <value>Allow extension 'Add' methods in collection initializer expressions</value>
  </data>
  <data name="DecompilerSettings_UseRefLocalsForAccurateOrderOfEvaluation" xml:space="preserve">
    <value>Use ref locals to accurately represent order of evaluation</value>
  </data>
  <data name="DecompilerSettings_UseStringInterpolation" xml:space="preserve">
    <value>Use string interpolation</value>
  </data>
  <data name="DecompilerSettings_UseExpressionBodiedMemberSyntaxForGetOnlyProperties" xml:space="preserve">
    <value>Use expression-bodied member syntax for get-only properties</value>
  </data>
  <data name="DecompilerSettings_UseOutVariableDeclarations" xml:space="preserve">
    <value>Use out variable declarations</value>
  </data>
  <data name="DecompilerSettings_UseDiscards" xml:space="preserve">
    <value>Use discards</value>
  </data>
  <data name="DecompilerSettings_UseTupleTypeSyntax" xml:space="preserve">
    <value>Use tuple type syntax</value>
  </data>
  <data name="DecompilerSettings_UseThrowExpressions" xml:space="preserve">
    <value>Use throw expressions</value>
  </data>
  <data name="DecompilerSettings_IntroduceLocalFunctions" xml:space="preserve">
    <value>Introduce local functions</value>
  </data>
  <data name="DecompilerSettings_Deconstruction" xml:space="preserve">
    <value>Detect deconstruction assignments</value>
  </data>
  <data name="DecompilerSettings_PatternMatching" xml:space="preserve">
    <value>Use pattern matching expressions</value>
  </data>
  <data name="DecompilerSettings_AllowExtensionMethodSyntaxOnRef" xml:space="preserve">
    <value>Use 'ref' extension methods</value>
  </data>
  <data name="DecompilerSettings_IsByRefLikeAttributeShouldBeReplacedWithRefModifiersOnStructs" xml:space="preserve">
    <value>IsByRefLikeAttribute should be replaced with 'ref' modifiers on structs</value>
  </data>
  <data name="DecompilerSettings_IsReadOnlyAttributeShouldBeReplacedWithReadonlyInModifiersOnStructsParameters" xml:space="preserve">
    <value>IsReadOnlyAttribute should be replaced with 'readonly'/'in' modifiers on structs/parameters</value>
  </data>
  <data name="DecompilerSettings_UseNonTrailingNamedArguments" xml:space="preserve">
    <value>Use non-trailing named arguments</value>
  </data>
  <data name="DecompilerSettings_IsUnmanagedAttributeOnTypeParametersShouldBeReplacedWithUnmanagedConstraints" xml:space="preserve">
    <value>IsUnmanagedAttribute on type parameters should be replaced with 'unmanaged' constraints</value>
  </data>
  <data name="DecompilerSettings_UseStackallocInitializerSyntax" xml:space="preserve">
    <value>Use stackalloc initializer syntax</value>
  </data>
  <data name="DecompilerSettings_UsePatternBasedFixedStatement" xml:space="preserve">
    <value>Use pattern-based fixed statement</value>
  </data>
  <data name="DecompilerSettings_NativeIntegers" xml:space="preserve">
    <value>Use nint/nuint types</value>
  </data>
  <data name="DecompilerSettings_InitAccessors" xml:space="preserve">
    <value>Allow init; accessors</value>
  </data>
  <data name="DecompilerSettings_RecordClasses" xml:space="preserve">
    <value>Record classes</value>
  </data>
  <data name="DecompilerSettings_WithExpressions" xml:space="preserve">
    <value>'with' initializer expressions</value>
  </data>
  <data name="DecompilerSettings_UsePrimaryConstructorSyntax" xml:space="preserve">
    <value>Use primary constructor  syntax with records</value>
  </data>
  <data name="DecompilerSettings_FunctionPointers" xml:space="preserve">
    <value>Function pointers</value>
  </data>
  <data name="DecompilerSettings_DecompileForEachWithGetEnumeratorExtension" xml:space="preserve">
    <value>Decompile foreach statements with GetEnumerator extension methods</value>
  </data>
  <data name="DecompilerSettings_RecordStructs" xml:space="preserve">
    <value>Record structs</value>
  </data>
  <data name="DecompilerSettings_FileScopedNamespaces" xml:space="preserve">
    <value>Use file-scoped namespace declarations</value>
  </data>
  <data name="DecompilerSettings_NumericIntPtr" xml:space="preserve">
    <value>Treat (U)IntPtr as n(u)int</value>
  </data>
  <data name="DecompilerSettings_ScopedRef" xml:space="preserve">
    <value>'scoped' lifetime annotation</value>
  </data>
  <data name="DecompilerSettings_RequiredMembers" xml:space="preserve">
    <value>Required members</value>
  </data>
  <data name="DecompilerSettings_Utf8StringLiterals" xml:space="preserve">
    <value>UTF-8 string literals</value>
  </data>
  <data name="DecompilerSettings_UnsignedRightShift" xml:space="preserve">
    <value>Unsigned right shift (&gt;&gt;&gt;)</value>
  </data>
  <data name="DecompilerSettings_CheckedOperators" xml:space="preserve">
    <value>User-defined checked operators</value>
  </data>
  <data name="DecompilerSettings_FullyQualifyAllTypes" xml:space="preserve">
    <value>Add namespaces to all types</value>
  </data>
  <data name="DecompilerSettings_FullyQualifyAmbiguousTypeNames" xml:space="preserve">
    <value>Add a namespace to types with the same name</value>
  </data>
  <data name="DecompilerSettings_HexadecimalNumbers" xml:space="preserve">
    <value>Hexadecimal numbers</value>
  </data>
  <data name="DecompilerSettings_EmitCalliAsInvocationExpression" xml:space="preserve">
    <value>Decompile calli to invocation expression</value>
  </data>
  <data name="DecompilerSettings_InsertParenthesesForReadability" xml:space="preserve">
    <value>Insert parentheses for readability</value>
  </data>
  <data name="DecompilerSettings_IntroduceIncrementAndDecrement" xml:space="preserve">
    <value>Use increment and decrement operators</value>
  </data>
  <data name="DecompilerSettings_MakeAssignmentExpressions" xml:space="preserve">
    <value>Use assignment expressions such as in while ((count = Do()) != 0) ;</value>
  </data>
  <data name="DecompilerSettings_MaxArrayElements" xml:space="preserve">
    <value>Max number of array elements to show</value>
  </data>
  <data name="DecompilerSettings_MaxStringLength" xml:space="preserve">
    <value>Max string length</value>
  </data>
  <data name="DecompilerSettings_MemberAddPrivateModifier" xml:space="preserve">
    <value>Add 'private' modifier to type members</value>
  </data>
  <data name="DecompilerSettings_ObjectOrCollectionInitializers" xml:space="preserve">
    <value>Decompile object or collection initializers</value>
  </data>
  <data name="DecompilerSettings_OneCustomAttributePerLine" xml:space="preserve">
    <value>Show one custom attribute per line</value>
  </data>
  <data name="DecompilerSettings_RemoveDeadCode" xml:space="preserve">
    <value>Remove dead and side effect free code (use with caution!)</value>
  </data>
  <data name="DecompilerSettings_RemoveDeadStores" xml:space="preserve">
    <value>Remove dead stores (use with caution!)</value>
  </data>
  <data name="DecompilerSettings_RemoveEmptyDefaultCtors" xml:space="preserve">
    <value>Remove empty default constructors</value>
  </data>
  <data name="DecompilerSettings_RemoveNewDelegateClass" xml:space="preserve">
    <value>Replace 'new delegate-class(xxx)' with 'xxx'</value>
  </data>
  <data name="DecompilerSettings_ShowCompilerGeneratedTypes" xml:space="preserve">
    <value>Show hidden compiler generated types and methods</value>
  </data>
  <data name="DecompilerSettings_ShowILComments" xml:space="preserve">
    <value>Show IL opcode comments</value>
  </data>
  <data name="DecompilerSettings_ShowILInstrBytes" xml:space="preserve">
    <value>Show IL instruction bytes</value>
  </data>
  <data name="DecompilerSettings_ShowPdbInfo" xml:space="preserve">
    <value>Show line numbers and filenames if available</value>
  </data>
  <data name="DecompilerSettings_ShowTokensRvasOffsets" xml:space="preserve">
    <value>Show tokens, RVAs and file offsets</value>
  </data>
  <data name="DecompilerSettings_ShowXMLDocComments" xml:space="preserve">
    <value>Show XML documentation in decompiled code</value>
  </data>
  <data name="DecompilerSettings_SortCustomAttributes" xml:space="preserve">
    <value>Sort custom attributes</value>
  </data>
  <data name="DecompilerSettings_SortMethods" xml:space="preserve">
    <value>Sort methods, fields, properties, events and types</value>
  </data>
  <data name="DecompilerSettings_SortSystemFirst" xml:space="preserve">
    <value>Place 'System' directives first when sorting usings</value>
  </data>
  <data name="DecompilerSettings_SortSwitchCasesByILOffset" xml:space="preserve">
    <value>Sort switch cases by IL instruction offset</value>
  </data>
  <data name="DecompilerSettings_TypeAddInternalModifier" xml:space="preserve">
    <value>Add 'internal' modifier to types</value>
  </data>
  <data name="DecompilerSettings_UseLocalNameFromSyms" xml:space="preserve">
    <value>Use variable names from debug symbols, if available</value>
  </data>
  <data name="DecompilerSettings_UseSourceCodeOrder" xml:space="preserve">
    <value>Order members in source code order</value>
  </data>
</root>
